[
    {
      "question": "Qual é o tipo de linguagem de programação do Dart?",
      "options": {
        "a": "Compilada para bytecode (como Java)",
        "b": "Interpretada (como Python)",
        "c": "Compilada para código nativo e JavaScript",
        "d": "Baseada em máquina virtual (como C#)"
      },
      "answer": "c",
      "answer_text": "Compilada para código nativo e JavaScript",
      "explanation": "Dart pode ser compilado tanto para código nativo (para aplicativos mobile e desktop) quanto para JavaScript (para aplicativos web)."
    },
    {
      "question": "Qual palavra-chave é usada para declarar uma variável que não pode ser alterada?",
      "options": {
        "a": "var",
        "b": "dynamic",
        "c": "final ou const",
        "d": "static"
      },
      "answer": "c",
      "answer_text": "final ou const",
      "explanation": "`final` e `const` são usados para declarar variáveis que têm um único valor atribuído a elas. `const` é para valores conhecidos em tempo de compilação, enquanto `final` é para valores que serão conhecidos em tempo de execução."
    },
    {
      "question": "Como se define uma função anônima em Dart?",
      "options": {
        "a": "function() { }",
        "b": "() => {}",
        "c": "() {} ou () =>' expr",
        "d": "lambda: {}"
      },
      "answer": "c",
      "answer_text": "() {} ou () => expr",
      "explanation": "Funções anônimas em Dart são funções sem nome, definidas usando a sintaxe `() {}` para um corpo de função completo ou `() => expr` para uma função de seta (arrow function) que retorna uma única expressão."
    },
    {
      "question": "Qual é a saída do seguinte código?\n\nvoid main() {\n  int x = 5;\n  print(x ~/ 2);\n}",
      "options": {
        "a": "2.5",
        "b": "2",
        "c": "3",
        "d": "Erro"
      },
      "answer": "b",
      "answer_text": "2",
      "explanation": "O operador `~/` realiza divisão inteira, descartando a parte decimal. Portanto, 5 dividido por 2 resulta em 2."
    },
    {
      "question": "Qual método é usado para converter uma String em int?",
      "options": {
        "a": "String.toInt()",
        "b": "int.parse()",
        "c": "int.fromString()",
        "d": "String.castToInt()"
      },
      "answer": "b",
      "answer_text": "int.parse()",
      "explanation": "O método `int.parse()` é usado para converter uma string em um valor inteiro."
    },
    {
      "question": "O que é Future em Dart?",
      "options": {
        "a": "Um tipo de lista assíncrona",
        "b": "Um objeto que representa um valor disponível no futuro",
        "c": "Um erro em tempo de execução",
        "d": "Um operador para concatenação"
      },
      "answer": "b",
      "answer_text": "Um objeto que representa um valor disponível no futuro",
      "explanation": "`Future` é usado para lidar com operações assíncronas, representando um resultado que estará disponível em algum momento no futuro."
    },
    {
      "question": "Qual é a forma correta de declarar uma lista de inteiros?",
      "options": {
        "a": "List<int> = [1, 2, 3];",
        "b": "List<int> list = [1, 2, 3];",
        "c": "Array<int> list = [1, 2, 3];",
        "d": "int[] list = [1, 2, 3];"
      },
      "answer": "b",
      "answer_text": "List<int> list = [1, 2, 3];",
      "explanation": "Esta é a sintaxe correta para declarar uma lista de inteiros em Dart."
    },
    {
      "question": "Como se define um construtor nomeado em Dart?",
      "options": {
        "a": "class MyClass { constructor.named(); }",
        "b": "class MyClass { MyClass.named(); }",
        "c": "class MyClass { new.named(); }",
        "d": "class MyClass { named(); }"
      },
      "answer": "b",
      "answer_text": "class MyClass { MyClass.named(); }",
      "explanation": "Construtores nomeados são definidos dentro da classe com o nome da classe seguido por um ponto e o nome do construtor."
    },
    {
      "question": "Qual é a saída do código abaixo?\n\nvoid main() {\n  var list = [1, 2, 3];\n  list.forEach((item) => print(item * 2));\n}",
      "options": {
        "a": "[2, 4, 6]",
        "b": "2, 4, 6 (um por linha)",
        "c": "null",
        "d": "Erro"
      },
      "answer": "b",
      "answer_text": "2, 4, 6 (um por linha)",
      "explanation": "O código itera sobre a lista e imprime cada elemento multiplicado por 2."
    },
    {
      "question": "Qual pacote é usado para fazer requisições HTTP em Dart?",
      "options": {
        "a": "dart:web",
        "b": "dart:io",
        "c": "http (pacote externo)",
        "d": "dart:net"
      },
      "answer": "c",
      "answer_text": "http (pacote externo)",
      "explanation": "O pacote `http` é um pacote externo amplamente utilizado para fazer requisições HTTP em Dart."
    },
    {
      "question": "O que async e await fazem?",
      "options": {
        "a": "Permitem trabalhar com código assíncrono de forma síncrona",
        "b": "Compilam código mais rápido",
        "c": "São usados para definir threads",
        "d": "Convertem JSON automaticamente"
      },
      "answer": "a",
      "answer_text": "Permitem trabalhar com código assíncrono de forma síncrona",
      "explanation": "`async` e `await` são usados para escrever código assíncrono que parece síncrono, facilitando a leitura e o entendimento."
    },
    {
      "question": "Qual é a função do operador ??",
      "options": {
        "a": "Retorna o valor à direita se o da esquerda for null",
        "b": "Verifica igualdade",
        "c": "Concatena strings",
        "d": "Faz divisão"
      },
      "answer": "a",
      "answer_text": "Retorna o valor à direita se o da esquerda for null",
      "explanation": "O operador `??` é o operador de coalescência nula. Ele retorna o valor à esquerda se não for nulo, caso contrário, retorna o valor à direita."
    },
    {
      "question": "Como se define um mapa (dicionário) em Dart?",
      "options": {
        "a": "Map<String, int> = {'key': 1};",
        "b": "Dict key = {'key': 1};",
        "c": "HashMap<String, int> = {'key': 1};",
        "d": "Map({'key': 1});"
      },
      "answer": "a",
      "answer_text": "Map<String, int> = {'key': 1};",
      "explanation": "Esta é a sintaxe correta para definir um mapa em Dart, especificando os tipos de chave e valor."
    },
    {
      "question": "Qual é a saída do código?\n\nvoid main() {\n  var a = [1, 2];\n  var b = [...a, 3];\n  print(b);\n}",
      "options": {
        "a": "[1, 2]",
        "b": "[1, 2, 3]",
        "c": "[3, 1, 2]",
        "d": "Erro"
      },
      "answer": "b",
      "answer_text": "[1, 2, 3]",
      "explanation": "O operador `...` é o operador spread, que insere todos os elementos de uma lista em outra."
    },
    {
      "question": "Qual método adiciona um item ao final de uma lista?",
      "options": {
        "a": "list.insert(item)",
        "b": "list.add(item)",
        "c": "list.push(item)",
        "d": "list.append(item)"
      },
      "answer": "b",
      "answer_text": "list.add(item)",
      "explanation": "O método `add()` é usado para adicionar um elemento ao final de uma lista."
    },
    {
      "question": "O que extends e implements significam?",
      "options": {
        "a": "extends herda uma classe, implements implementa uma interface",
        "b": "Ambos fazem herança múltipla",
        "c": "implements herda, extends implementa",
        "d": "São iguais"
      },
      "answer": "a",
      "answer_text": "extends herda uma classe, implements implementa uma interface",
      "explanation": "`extends` é usado para herança de classe, enquanto `implements` é usado para implementar interfaces."
    },
    {
      "question": "Qual é o tipo de var x = 1.0; ?",
      "options": {
        "a": "int",
        "b": "double",
        "c": "num",
        "d": "dynamic"
      },
      "answer": "b",
      "answer_text": "double",
      "explanation": "Quando você atribui um valor decimal a uma variável `var`, o Dart infere o tipo como `double`."
    },
    {
      "question": "Como se lê um arquivo em Dart?",
      "options": {
        "a": "File('path').readAsString()",
        "b": "readFile('path')",
        "c": "File.read('path')",
        "d": "importFile('path')"
      },
      "answer": "a",
      "answer_text": "File('path').readAsString()",
      "explanation": "Esta é a maneira correta de ler o conteúdo de um arquivo como uma string em Dart."
    },
    {
      "question": "Qual é a saída do código?\n\nvoid main() {\n  String? name;\n  print(name?.length ?? 0);\n}",
      "options": {
        "a": "null",
        "b": "Erro",
        "c": "0",
        "d": "1"
      },
      "answer": "c",
      "answer_text": "0",
      "explanation": "O operador `?.` acessa o comprimento de `name` apenas se `name` não for nulo. Se for nulo, retorna nulo. O operador `??` então fornece um valor padrão de 0 se o resultado anterior for nulo."
    },
    {
      "question": "Qual ferramenta compila Dart para JavaScript?",
      "options": {
        "a": "dart2js",
        "b": "dartc",
        "c": "flutter build",
        "d": "dart-web"
      },
      "answer": "a",
      "answer_text": "dart2js",
      "explanation": "`dart2js` é a ferramenta que compila código Dart para JavaScript."
    },
    {
      "question": "Como se define uma classe em Dart?",
      "options": {
        "a": "class MyClass {}",
        "b": "def MyClass {}",
        "c": "object MyClass {}",
        "d": "new class MyClass { }"
      },
      "answer": "a",
      "answer_text": "class MyClass {}",
      "explanation": "Esta é a sintaxe básica para definir uma classe em Dart."
    },
    {
      "question": "Qual é a palavra-chave para criar uma instância de uma classe?",
      "options": {
        "a": "create",
        "b": "new (opcional no Dart 2+)",
        "c": "instance",
        "d": "make"
      },
      "answer": "b",
      "answer_text": "new (opcional no Dart 2+)",
      "explanation": "Embora `new` seja usado para criar instâncias, ele se tornou opcional no Dart 2 e versões posteriores."
    },
    {
      "question": "Como declarar um construtor padrão para a classe Pessoa?",
      "options": {
        "a": "Pessoa() => {}",
        "b": "Pessoa();",
        "c": "constructor() { }",
        "d": "Pessoa.new() {}"
      },
      "answer": "b",
      "answer_text": "Pessoa();",
      "explanation": "Esta é a sintaxe para um construtor padrão sem parâmetros."
    },
    {
      "question": "O que é herança em Dart?",
      "options": {
        "a": "Uma classe pode herdar propriedades e métodos de outra classe usando extends",
        "b": "Uma classe pode ter múltiplas superclasses",
        "c": "Só é possível herdar interfaces",
        "d": "Herança é feita com a palavra-chave inherit"
      },
      "answer": "a",
      "answer_text": "Uma classe pode herdar propriedades e métodos de outra classe usando extends",
      "explanation": "Herança em Dart é feita usando a palavra-chave `extends`."
    },
    {
      "question": "Qual é a saída do código abaixo?\n\nclass Animal {\n  void emitirSom() => print('Som genérico');\n}\n\nclass Cachorro extends Animal {\n  void emitirSom() => print('Au au!');\n}\n\nvoid main() {\n  Animal animal = Cachorro();\n  animal.emitirSom();\n}",
      "options": {
        "a": "Som genérico",
        "b": "Au au!",
        "c": "Erro",
        "d": "null"
      },
      "answer": "b",
      "answer_text": "Au au!",
      "explanation": "O método `emitirSom()` da classe `Cachorro` sobrescreve o método da classe `Animal`. Portanto, quando `animal.emitirSom()` é chamado, a versão da classe `Cachorro` é executada."
    },
    {
      "question": "Como declarar um método privado em Dart?",
      "options": {
        "a": "Usando private antes do método",
        "b": "Prefixando o nome do método com _",
        "c": "Usando a palavra-chave hidden",
        "d": "Métodos não podem ser privados"
      },
      "answer": "b",
      "answer_text": "Prefixando o nome do método com _",
      "explanation": "Em Dart, membros privados de uma classe são prefixados com um sublinhado (`_`). Isso restringe o acesso ao membro à biblioteca em que é declarado."
    },
    {
      "question": "Como definir um construtor nomeado que inicializa apenas o nome de uma classe Pessoa?\n\nclass Pessoa {\n  String nome;\n  int idade;\n  // Construtor padrão\n  Pessoa(this.nome, this.idade);\n  // Construtor nomeado aqui\n}",
      "options": {
        "a": "Pessoa.novo(String n) { nome = n; }",
        "b": "Pessoa.somenteNome(this.nome);",
        "c": "named Pessoa(String n) => nome = n;",
        "d": "Pessoa({this.nome});"
      },
      "answer": "b",
      "answer_text": "Pessoa.somenteNome(this.nome);",
        "explanation": "Construtores nomeados são definidos com um ponto após o nome da classe. O construtor `Pessoa.somenteNome(this.nome);` inicializa apenas o nome."
    },
    {
      "question": "Qual é a diferença entre extends e implements?",
      "options": {
        "a": "extends herda tudo, implements só métodos",
        "b": "extends herda atributos e métodos, implements obriga a implementar todos os métodos",
        "c": "São sinônimos",
        "d": "implements herda, extends implementa"
      },
      "answer": "b",
      "answer_text":"extends herda atributos e métodos, implements obriga a implementar todos os métodos",
    "explanation": "`extends` permite herdar de uma classe base, enquanto `implements` força a classe a fornecer uma implementação para todos os membros de uma interface."
  },
  {
    "question": "Como definir uma classe abstrata?",
    "options": {
      "a": "abstract class Veiculo { ... }",
      "b": "class abstract Veiculo { ... }",
      "c": "Veiculo with abstract { ... }",
      "d": "interface Veiculo { ... }"
    },
    "answer": "a",
    "answer_text": "abstract class Veiculo { ... }",
    "explanation": "Classes abstratas são definidas usando a palavra-chave `abstract`."
  },
  {
    "question": "Qual é a saída do código?\n\nclass Contador {\n  static int count = 0;\n  Contador() { count++; }\n}\n\nvoid main() {\n  Contador();\n  Contador();\n  print(Contador.count);\n}",
    "options": {
      "a": "0",
      "b": "2",
      "c": "1",
      "d": "Erro"
    },
    "answer": "b",
    "answer_text": "2",
    "explanation": "A variável `count` é estática, o que significa que ela é compartilhada entre todas as instâncias da classe `Contador`. Cada vez que o construtor é chamado, `count` é incrementado."
  },
  {
    "question": "Qual widget é usado para criar um botão clicável em Flutter?",
    "options": {
      "a": "Clickable",
      "b": "ElevatedButton",
      "c": "TouchableOpacity",
      "d": "Button"
    },
    "answer": "b",
    "answer_text": "ElevatedButton",
    "explanation": "`ElevatedButton` é um dos widgets padrão para criar botões com elevação em Flutter."
  },
  {
    "question": "Qual é a função do widget Scaffold?",
    "options": {
      "a": "Fornece uma estrutura básica de layout (AppBar, Body, FloatingActionButton, etc.)",
      "b": "Gerencia estados de widgets",
      "c": "Navega entre telas",
      "d": "Cria listas roláveis"
    },
    "answer": "a",
    "answer_text": "Fornece uma estrutura básica de layout (AppBar, Body, FloatingActionButton, etc.)",
    "explanation": "`Scaffold` fornece a estrutura básica para a maioria das telas em um aplicativo Flutter, incluindo AppBar, corpo, botões flutuantes, etc."
  },
  {
    "question": "Qual widget é usado para exibir uma lista rolável?",
    "options": {
      "a": "Column",
      "b": "ListView",
      "c": "Stack",
      "d": "Grid"
    },
    "answer": "b",
    "answer_text": "ListView",
    "explanation": "`ListView` é usado para exibir uma sequência de widgets filhos que podem ser rolados."
  },
  {
    "question": "Qual é a diferença entre StatelessWidget e StatefulWidget?",
    "options": {
      "a": "StatelessWidget é imutável, StatefulWidget pode mudar dinamicamente",
      "b": "StatelessWidget usa setState(), StatefulWidget não",
      "c": "StatefulWidget não pode ter filhos",
      "d": "São idênticos"
    },
    "answer": "a",
    "answer_text": "StatelessWidget é imutável, StatefulWidget pode mudar dinamicamente",
    "explanation": "`StatelessWidget` é usado para partes da interface do usuário que não mudam dinamicamente, enquanto `StatefulWidget` é usado para partes que podem mudar em resposta a eventos ou interação do usuário."
  },
  {
    "question": "Como navegar para uma nova tela (Tela2) em Flutter?",
    "options": {
      "a": "Navigator.push(context, MaterialPageRoute(builder: (context) => Tela2()));",
      "b": "Navigator.goTo(Tela2());",
      "c": "context.changeScreen(Tela2());",
      "d": "Route.switch(Tela2());"
    },
    "answer": "a",
    "answer_text": "Navigator.push(context, MaterialPageRoute(builder: (context) => Tela2()));",
    "explanation": "`Navigator.push` é usado para adicionar uma nova rota à pilha de navegação, exibindo uma nova tela."
  },
  {
    "question": "Qual widget é usado para centralizar um filho horizontal e verticalmente?",
    "options": {
      "a": "Align",
      "b": "Center",
      "c": "Padding",
      "d": "Container"
    },
    "answer": "b",
    "answer_text": "Center",
    "explanation": "O widget `Center` centraliza seu widget filho dentro de si mesmo."
  },
  {
    "question": "Qual método é chamado quando um StatefulWidget é inicializado?",
    "options": {
      "a": "onCreate()",
      "b": "initState()",
      "c": "build()",
      "d": "start()"
    },
    "answer": "b",
    "answer_text": "initState()",
    "explanation": "`initState()` é chamado uma vez quando o widget é inserido na árvore de widgets, antes do método `build()` ser chamado."
  },
  {
    "question": "Qual widget permite adicionar espaçamento interno ao redor de outro widget?",
    "options": {
      "a": "Margin",
      "b": "Padding",
      "c": "Spacer",
      "d": "Space"
    },
    "answer": "b",
    "answer_text": "Padding",
    "explanation": "`Padding` adiciona espaço dentro das bordas do widget filho."
  },
  {
    "question": "Como retornar à tela anterior na navegação?",
    "options": {
      "a": "Navigator.back();",
      "b": "Navigator.pop(context);",
      "c": "context.goBack();",
      "d": "Route.pop();"
    },
    "answer": "b",
    "answer_text": "Navigator.pop(context);",
    "explanation": "`Navigator.pop(context)` remove a rota atual da pilha de navegação, retornando à tela anterior."
  },
  {
    "question": "Qual widget é usado para organizar widgets verticalmente?",
    "options": {
      "a": "Column",
      "b": "Row",
      "c": "List",
      "d": "VerticalLayout"
    },
    "answer": "a",
    "answer_text": "Column",
    "explanation": "`Column` organiza os widgets filhos em uma direção vertical."
  },
  {
    "question": "O que o método setState() faz em um StatefulWidget?",
    "options": {
      "a": "Atualiza o estado interno e força o rebuild do widget",
      "b": "Remove o widget da árvore",
      "c": "Navega para outra tela",
      "d": "Inicializa o estado"
    },
    "answer": "a",
    "answer_text": "Atualiza o estado interno e força o rebuild do widget",
    "explanation": "`setState()` notifica o framework que o estado interno do widget mudou, o que aciona uma reconstrução da interface do usuário."
  },
  {
    "question": "Qual widget é usado para exibir texto em Flutter?",
    "options": {
      "a": "Label",
      "b": "Text",
      "c": "StringView",
      "d": "TextView"
    },
    "answer": "b",
    "answer_text": "Text",
    "explanation": "O widget `Text` é usado para exibir uma string de texto."
  },
  {
    "question": "Como adicionar margens a um widget?",
    "options": {
      "a": "Usar Container com margin",
      "b": "Usar Padding com edgeInsets",
      "c": "Usar Spacer",
      "d": "Não é possível"
    },
    "answer": "a",
    "answer_text": "Usar Container com margin",
    "explanation": "Você pode adicionar margens usando a propriedade `margin` do widget `Container`."
  },
  {
    "question": "Qual widget permite sobrepor widgets uns sobre os outros?",
    "options": {
      "a": "Stack",
      "b": "Column",
      "c": "Overlay",
      "d": "Layer"
    },
    "answer": "a",
    "answer_text": "Stack",
    "explanation": "O widget `Stack` permite posicionar widgets filhos em cima uns dos outros."
  },
  {
    "question": "Qual é o widget raiz obrigatório em um app Flutter?",
    "options": {
      "a": "MaterialApp ou CupertinoApp",
      "b": "Scaffold",
      "c": "AppBar",
      "d": "MainWidget"
    },
    "answer": "a",
    "answer_text": "MaterialApp ou CupertinoApp",
    "explanation": "`MaterialApp` (para design Material) ou `CupertinoApp` (para design iOS) são os widgets raiz que configuram o aplicativo."
  },
  {
    "question": "Como definir um ícone no AppBar?",
    "options": {
      "a": "AppBar(leading: Icon(Icons.menu));",
      "b": "AppBar(icon: Icons.menu);",
      "c": "AppBar(child: Icon(Icons.menu));",
      "d": "AppBar(action: Icon(Icons.menu));"
    },
    "answer": "a",
    "answer_text": "AppBar(leading: Icon(Icons.menu));",
    "explanation": "Use `leading` para um ícone no início (esquerda) ou `actions` para ícones à direita do `AppBar`."
  },
  {
    "question": "Qual widget é usado para criar um campo de texto editável?",
    "options": {
      "a": "TextField",
      "b": "TextInput",
      "c": "EditText",
      "d": "Input"
    },
    "answer": "a",
    "answer_text": "TextField",
    "explanation": "`TextField` é o widget padrão para entrada de texto do usuário."
  },
  {
    "question": "O que o widget SizedBox faz?",
    "options": {
      "a": "Define um tamanho fixo para seu filho ou espaçamento",
      "b": "Cria uma caixa de texto",
      "c": "Gerencia estados",
      "d": "Navega entre telas"
    },
    "answer": "a",
    "answer_text": "Define um tamanho fixo para seu filho ou espaçamento",
    "explanation": "`SizedBox` é usado para impor uma altura e/ou largura específicas a um widget."
  },
  {
    "question": "Qual widget é usado para criar um switch (interruptor)?",
    "options": {
      "a": "Switch",
      "b": "Toggle",
      "c": "Checkbox",
      "d": "Button"
    },
    "answer": "a",
    "answer_text": "Switch",
    "explanation": "`Switch` é um widget de interruptor on/off."
  },
  {
    "question": "Qual é a função do BuildContext?",
    "options": {
      "a": "Representa a localização de um widget na árvore de widgets",
      "b": "Gerencia estados globais",
      "c": "Armazena dados persistentes",
      "d": "Navega entre telas"
    },
    "answer": "a",
    "answer_text": "Representa a localização de um widget na árvore de widgets",
    "explanation": "`BuildContext` fornece informações sobre a localização do widget na árvore, permitindo que o widget interaja com outros widgets e o framework."
  }
]